% runButtonPushed_.m
% Author      : Tian Gao (tgaochn@gmail.com)
% Link        :
% Date        : 2021/04/16, 21:57:10
% Description :
%   real function to run when clicking the button
%%

%

function runButtonPushed_(app, event)
    %  -- ================================================ Header =====================================================

    %  -- ================================================ App Component ==============================================
    inputHeaderPathField = app.imageheaderpathhdrEditField;
    inputImgPathField = app.imagedatapathEditField;
    whiteRefHeaderPathField = app.whitereferenceheaderpathEditField;
    whiteRefDataPathField = app.whitereferencedatapathEditField;
    darkRefHeaderPathField = app.darkreferenceheaderpathEditField;
    darkRefDataPathField = app.darkreferencedatapathEditField;
    outputDataPathField = app.outputdatapathEditField;
    inputDataTypeField = app.inputdatatypeDropDown;
    removeBandsCheckBoxField = app.removebandsCheckBox;
    enableOverwritingCheckBoxField = app.enableoverwritingCheckBox;
    seedSegFigField = app.segTestFig;
    lampField = app.Lamp;
    bandIDField = app.bandID;
    minIntenField = app.minInten;
    maxIntenField = app.maxInten;
    minPixelInClusteringField = app.minPixelForClustering;
    enableellipsefittingCheckBoxField = app.enableellipsefittingCheckBox;

    % Lamp turns red when running
    lampField.Color = 'red';

    %  -- ================================================ Global Variables ============================================
    inputHeaderFilenames = inputHeaderPathField.Value;
    inputImgFilenames = inputImgPathField.Value;
    whiteRefHeaderFilenames = whiteRefHeaderPathField.Value;
    whiteRefImgFilenames = whiteRefDataPathField.Value;
    darkRefHeaderFilenames = darkRefHeaderPathField.Value;
    darkRefImgFilenames = darkRefDataPathField.Value;
    outputRltPath = outputDataPathField.Value;

    % ! input data type drop down menu
    %   1: 'intensity w/o reference'
    %   2: 'reflectance w/t uniform reference'
    totalDataTypeCnt = length(inputDataTypeField.Items);
    enabledType = inputDataTypeField.Value;
    for i = 1:totalDataTypeCnt
        curItemVlaue = inputDataTypeField.Items{i};
        if strcmp(enabledType, curItemVlaue)
            enabledType = i;
            break
        end
    end
    bandRemovalFlag = removeBandsCheckBoxField.Value;
    overwriteFlag = enableOverwritingCheckBoxField.Value;
    ellipseFittingFlag = enableellipsefittingCheckBoxField.Value;

    initLogger(app)
    logger = app.logger;
    logger.info('=======================')

    % disp(enabledType)
    % disp(bandRemovalFlag)
    % disp(overwriteFlag)
    % return
    %  -- ================================================ Files =======================================================

    [~, headerLocalFn, headerExt] = fileparts(inputHeaderFilenames);
    [~, imgLocalFn, imgExt] = fileparts(inputImgFilenames);
    hcubeLocalFn = [imgLocalFn, imgExt];
    hcubeHeaderLocalFn = [headerLocalFn, headerExt];

    % ! input local fn
    autoGenImgLocalFn = 'image.png';  % the 2D image generated by camera

    % ! output local fn - for each folder
    midRltFolderLocalPath = 'hyperSeed';
    rltLocalFn = 'seedSpectrum.csv';
    seedMaskFolderLocalPath = 'seedMask';
    allSeedMaskImgLocalFn = 'rawSeedBW.png';
    allSeedColoredMaskImgLocalFn = 'allSeedColored.png';
    allSeedLabeledMaskImgLocalFn = 'allSeedLabeled.png';

    pixelSpectrumLocalPath = 'pixelSpectrum';
    ROIFolderLocalPath = 'seedROI';

    % ! output fn - merged rlt
    mergedRltFn = fullfile(outputRltPath, 'mergedRlt.csv');

    %  -- ================================================ Global Parameters ==========================================
    % !! process control
    run1stDataForTesting = false;  % only run the first dataset
    onlyShowSeedMask = false;
    enabledResizeType = {'padding'};

    % bandId = 20;
    bandId = str2num(bandIDField.Value);
    minInten = str2num(minIntenField.Value);
    maxInten = str2num(maxIntenField.Value);
    skipIfWarning = false;
    showFigFlag = false;
    finalCubeWidth = 64;
    finalCubeHeight = 64;    
    % minSeedAreaThres = 500;
    minSeedAreaThres = str2num(minPixelInClusteringField.Value);

    % !! IO control
    useSameFolderAsOutput = false;

    % !! other parameters
    minHyperDataFileSize = 100;  % in Mb

    % para defined by overlap segment algorithm
    global Constraints
    Constraints = [250 0.1 0.2];

    % threshold to remove noise for seed segment
    minAreaThres = 100;
    adaptiveThresSens = 0.1;

    %  -- ================================================ Main =======================================================

    files = dir(inputHeaderFilenames);
    N = length(files);
    mergedRltTbl = table();

    if N == 0
        logger.info('ERROR: No files found! Please check the input folder.');
        logger.info(inputHeaderFilenames);
        return
    else
        logger.info(['total number of datasets: ', num2str(N)]);
    end
    logger.info('begin to process seeds...');

    whiteDataFn = whiteRefImgFilenames;
    whiteHeaderFn = whiteRefHeaderFilenames;
    darkDataFn = darkRefImgFilenames;
    darkHeaderFn = darkRefHeaderFilenames;

    checkFiles = {whiteDataFn, whiteHeaderFn, darkDataFn, darkHeaderFn};
    if enabledType == 2
        for curFn = checkFiles
            curFn = curFn{:};
            if ~exist(curFn, 'file')
                logger.info(['ERROR: files do not exist: ', curFn]);
                return
            end
        end
    end

    if length(outputRltPath) == 0
        logger.info(['ERROR: Please check the output path. ', outputRltPath]);
        return
    end

    % ! main loop
    for i = 1:N
        % close all hidden
        % close all force
        if exist('fig', 'var')
            close(fig)
        end
        logger.info('------');
        inputPath = files(i).folder;
        logger.info(['current folder: ', inputPath]);

        curDatasetOutputPath = fullfile(inputPath, midRltFolderLocalPath);
        hcubeFn = fullfile(inputPath, hcubeLocalFn);
        hcubeHeaderFn = fullfile(inputPath, hcubeHeaderLocalFn);
        autoGenImgFn = fullfile(inputPath, autoGenImgLocalFn);
        
        % output
        curRltFn = fullfile(curDatasetOutputPath, rltLocalFn);

        seedMaskFolderPath = fullfile(curDatasetOutputPath, seedMaskFolderLocalPath);
        allSeedMaskImgFn = fullfile(curDatasetOutputPath, allSeedMaskImgLocalFn);
        allSeedColoredMaskImgFn = fullfile(curDatasetOutputPath, allSeedColoredMaskImgLocalFn);
        allSeedLabeledMaskImgFn = fullfile(curDatasetOutputPath, allSeedLabeledMaskImgLocalFn);
        seedROIFolderPath = fullfile(curDatasetOutputPath, ROIFolderLocalPath);
        logger.info(['mid-results output folder: ', curDatasetOutputPath]);

        checkFiles = {hcubeFn, hcubeHeaderFn};
        for curFn = checkFiles
            curFn = curFn{:};
            if ~exist(curFn, 'file')
                logger.info(['ERROR: files do not exist: ', curFn]);
                return
            end
        end

        if exist(curRltFn, 'file') &&~overwriteFlag
            logger.info('intensity result file exists. folder skipped.')
            curRltTable = readtable(curRltFn, 'Delimiter', ',');
            mergedRltTbl = [mergedRltTbl; curRltTable];
            continue
        end

        if ~exist(seedMaskFolderPath, 'dir') % folder for output is included
            mkdir(seedMaskFolderPath)
        end
        if ~exist(seedROIFolderPath, 'dir') % folder for output is included
            mkdir(seedROIFolderPath)
        end

        % ! load hyper datacube and img
        hcubeObj = hypercube(hcubeFn, hcubeHeaderFn);
        bandCnt = size(hcubeObj.Wavelength, 1);
        % bandId = floor(bandCnt / 13);

        if bandId > bandCnt
            logger.info(sprintf('ERROR: band id (%d) should not be larger than total band count (%d).', bandId, bandCnt));
            return
        end

        slicingImg = hcubeObj.DataCube(:, :, bandId);
        imgSizeX = size(slicingImg, 1);
        imgSizeY = size(slicingImg, 2);
        if bandRemovalFlag
            invalidBandRange = [1:ceil(bandCnt * 0.05), floor(bandCnt * 0.95):bandCnt]; 
        else 
            invalidBandRange = [];
        end
                    

        % !! step 1: get the seed mask from hypercube
        % ! Adaptive image threshold -- more pixel more noise
        % adaThres = adaptthresh(slicingImg, adaptiveThresSens);
        % seedMask1 = imbinarize(slicingImg, adaThres);
        % seedMask1Final = bwareaopen(seedMask1, minAreaThres);
        % seedMask1Final = imfill(seedMask1Final, 'holes');

        % ! sliced img intensity -- incomplete seed
        % hcubeClass = class(hcubeObj.DataCube);  % 'uint16'
        % intensityScale = floor(double(intmax(hcubeClass)) / double(intmax('uint8')));
        % scaledImg = uint8(slicingImg / intensityScale);
        % seedMask2 = scaledImg > 1;
        % seedMask2 = scaledImg >= minInten & scaledImg <= maxInten;
        seedMask2 = slicingImg >= minInten & slicingImg <= maxInten;
        seedMask2Final = bwareaopen(seedMask2, minAreaThres);
        seedMask2Final = imfill(seedMask2Final, 'holes');

        % ! region mask
        [seedMinX, seedMaxX, seedMinY, seedMaxY, ~, ~] = getLocFromBW(seedMask2Final);
        seedMinX = max(1, seedMinX - imgSizeX * 0.05);
        seedMaxX = min(imgSizeX, seedMaxX + imgSizeX * 0.05);
        regionMask = false(imgSizeX, imgSizeY);
        % regionMask(seedMinX: seedMaxX, seedMinY: seedMaxY) = true;
        regionMask(seedMinX:seedMaxX, :) = true;
        % seedMaskFinal = (seedMask1Final | seedMask2Final) & regionMask;
        seedMaskFinal = seedMask2Final & regionMask;

        % ! save the raw seed mask
        fig = figure('visible', 'off');
        if exist(autoGenImgFn, 'file')
            coloredImg = imread(autoGenImgFn);
            imshowpair(coloredImg, seedMaskFinal, 'montage');
        else
            imshow(seedMaskFinal)
        end
        title(['bandID:', num2str(bandId)])
        saveas(fig, allSeedMaskImgFn)

        % !! step 2: generate a list of BW for each seed
        [labels, seedClusterCnt] = bwlabel(seedMaskFinal);
        BWlist = {};
        validSeedCnt = 0;
        labeledMask = uint8(zeros(imgSizeX, imgSizeY));  % merge all the seeds in labeled mask

        % compute median pixel count for overlapped seeds segmentation
        pixelCntArray = [];
        for j = 1:seedClusterCnt
            pixelCnt = length(find(labels == j));
            if pixelCnt < minSeedAreaThres
                continue
            end
            pixelCntArray(end + 1) = pixelCnt;
        end
        medSeedPixelCnt = median(pixelCntArray);

        % process each seed cluster (may include multiple seeds if overlapping)
        for j = 1:seedClusterCnt
            clusterPixelCnt = length(find(labels == j));
            if clusterPixelCnt < medSeedPixelCnt * 0.3 % filterout too small seeds
                continue
            end
            curClusterBW = zeros(imgSizeX, imgSizeY);
            curClusterBW(labels == j) = 1;
            if ellipseFittingFlag
                % RFOVE for ellipse-shaped fitting
                [overlappedLabels, seedCntInCluster] = segSeedOverlap(curClusterBW);

                % reverse the overlapping seeds segmentation if the seeds are too small
                for k = 1:seedCntInCluster
                    seedPixelCnt = length(find(overlappedLabels == k));
                    if seedPixelCnt < medSeedPixelCnt * 0.5
                        seedCntInCluster = 1;
                        overlappedLabels = curClusterBW;
                        break
                    end
                end
            else
                seedCntInCluster = 1;
                overlappedLabels = curClusterBW;
            end

            % process each segmented seed
            for k = 1:seedCntInCluster
                seedPixelCnt = length(find(overlappedLabels == k));
                curSeedBW = zeros(imgSizeX, imgSizeY);
                curSeedBW(overlappedLabels == k) = 1;

                % filter seeds on the edge of the image
                imgMargin = 10;
                [~, ~, seedMinY, seedMaxY, ~, ~] = getLocFromBW(curSeedBW);
                if seedMinY <= imgMargin || seedMaxY >= imgSizeY - imgMargin
                    continue
                end

                % find the center of the seeds
                [I, J] = find(curSeedBW);
                seedPosX = mean(I);
                seedPosY = mean(J);
                if isnan(seedPosX) || isnan(seedPosY)
                    continue
                end
                seedPos = {seedPosX, seedPosY};

                % improve seed mask by filling the cave on edge using boundary
                curSeedBW = logical(curSeedBW);
                boundaries = bwboundaries(curSeedBW);  % boundary pixel pos

                if length(boundaries) == 1 % only keep the largest one in case there are separate parts after overlapping seeds segmentation
                    b = boundaries{1};
                else
                    maxSeedBoundaryId = 1;
                    maxSeedBoundaryPtsCnt = size(boundaries{1}, 1);
                    for l = 2:length(boundaries)
                        curSeedBoundaryPtsCnt = size(boundaries{1}, 1);
                        if curSeedBoundaryPtsCnt > maxSeedBoundaryPtsCnt
                            maxSeedBoundaryPtsCnt = curSeedBoundaryPtsCnt;
                            maxSeedBoundaryId = l;
                        end
                    end
                    b = boundaries{maxSeedBoundaryId};
                end
                bx = b(:, 2);
                by = b(:, 1);
                ptsID = boundary(bx, by, 0.01);  % ID of the points connecting the edges (cave is filled in this step)
                curSeedBWFinal = poly2mask(bx(ptsID), by(ptsID), imgSizeX, imgSizeY);

                labeledMask(curSeedBWFinal) = validSeedCnt + 1;
                BWlist{end + 1} = {curSeedBWFinal, seedPixelCnt, seedPos};  % BW, seedPixelCnt, seedPos
                validSeedCnt = validSeedCnt + 1;

                curSeedMaskFn = fullfile(seedMaskFolderPath, ['seedMask_', num2str(validSeedCnt), '.png']);
                imwrite(BWlist{validSeedCnt}{1}, curSeedMaskFn)

                % disp(['id: ', num2str(validSeedCnt), ', seedPixelCnt: ', num2str(seedPixelCnt), ', medPixelCnt: ', num2str(medSeedPixelCnt)])
            end
        end

        % ! save the seed mask
        fig = figure('visible', 'off');
        coloredMaskImg = label2rainbow(labeledMask);
        posArr = [];
        textArr = [];
        for j = 1:validSeedCnt
            posArr(end + 1, :) = [BWlist{j}{3}{2}, BWlist{j}{3}{1}];
            textArr(end + 1) = j;
            coloredMaskImg = insertText(coloredMaskImg, posArr, textArr, 'FontSize', 18, 'BoxOpacity', 0);
        end
        if exist(autoGenImgFn, 'file')
            coloredImg = imread(autoGenImgFn);
            imshowpair(coloredImg, coloredMaskImg, 'montage');
        else
            imshow(coloredMaskImg)
        end
        title(['total number of seed:', num2str(validSeedCnt)])
        saveas(fig, allSeedColoredMaskImgFn)

        fig = figure('visible', 'off');
        labeledMask = uint8(labeledMask);
        imshow(labeledMask)
        saveas(fig, allSeedLabeledMaskImgFn)

        % show mask img of the first dataset in the UI
        if i == 1
            imagesc(seedSegFigField, coloredMaskImg);
        end

        % !! step 3: generate band from calibrated hypercube using the seed mask
        % continue if no seed
        if validSeedCnt == 0
            logger.info("WARNNING: there is no seed!")
            logger.info(inputPath)
            delete(runningFlagFn)
            continue
        end

        % ! get reference
        % load dark/white ref only for the 1st run
        %    enabledType==1: 'intensity w/o reference'
        %    enabledType==2: 'reflectance w/t uniform reference'
        if enabledType == 1
            seedReflArr = hcubeObj.DataCube;
        elseif enabledType == 2
            % load ref
            if (i == 1 && enabledType == 2) || exist('darkRefIntArr', 'var') == 0 || exist('whiteRefIntArr', 'var') == 0
                whiteRefHcubeObj = hypercube(whiteDataFn, whiteHeaderFn);
                darkRefHcubeObj = hypercube(darkDataFn, darkHeaderFn);
                whiteRefIntArr = getDataFromHypercube(whiteRefHcubeObj, true);
                darkRefIntArr = getDataFromHypercube(darkRefHcubeObj, true);
            end

            % calibrate the intensity with dark/white reference by computing reflectance
            seedIntArr = hcubeObj.DataCube;
            seedReflArr = zeros(size(seedIntArr));
            for j = 1:bandCnt
                seedReflArr(:, :, j) = (double(seedIntArr(:, :, j)) - darkRefIntArr(j)) ./ (whiteRefIntArr(j) - darkRefIntArr(j));
            end
        else
            logger.info(['ERROR: wrong reference type: ', num2str(enabledType)]);
            return
        end
        wavelengthArr = hcubeObj.Wavelength;

        % ! process non-ROI for each mask
        enabledResizeType = ['originalRegion', enabledResizeType];
        mergedSeedwiseSpectrum = [];  % store averaged data for table
        extraInvalidSeedCnt = 0;
        for j = 1:validSeedCnt
            curMask = BWlist{j}{1};
            pixelCnt = BWlist{j}{2};

            % skip invalid mask
            if nnz(curMask) == 0
                logger.warn(sprintf('empty mask for seed %02d', j));
                extraInvalidSeedCnt = extraInvalidSeedCnt + 1;
                continue
            end

            % ! generate seed-wise averaged spectrum
            % get the filtered hypercube
            curSeedHcubeData = seedReflArr;
            curSeedHcubeData(repmat(~curMask, [1 1 bandCnt])) = 0;

            % get a seed-based averaged value
            pixelwiseAvg = sum(curSeedHcubeData, [1, 2]) / pixelCnt;
            seedAvgValOnBands = reshape(pixelwiseAvg, [bandCnt, 1]);
            mergedSeedwiseSpectrum = [mergedSeedwiseSpectrum; seedAvgValOnBands'];

            % ! generate pixel-wise averaged spectrum
            % get bounding box
            curSeedHcubeData = seedReflArr;
            curSeedHcubeData(repmat(~curMask, [1 1 bandCnt])) = 0;
            curSeedHcube = hypercube(curSeedHcubeData, wavelengthArr);
            boundingBoxBW = floor(regionprops(curMask, 'Boundingbox').BoundingBox);

            % generate all the enabled type of ROI
            for k = 1:length(enabledResizeType)
                resizeType = enabledResizeType{k};
                finalOutputMatPath = fullfile(curDatasetOutputPath, pixelSpectrumLocalPath, resizeType);
                if ~exist(finalOutputMatPath, 'dir') % folder for output is included
                    mkdir(finalOutputMatPath)
                end

                xBoundingBox = boundingBoxBW(1);
                yBoundingBox = boundingBoxBW(2);
                wBoundingBox = boundingBoxBW(3);
                hBoundingBox = boundingBoxBW(4);
                row = xBoundingBox:xBoundingBox + wBoundingBox;
                col = yBoundingBox:yBoundingBox + hBoundingBox;
                rawSeedRegHcube = cropData(curSeedHcube, col, row);
                rawSeedRegionData = rawSeedRegHcube.DataCube;

                if strcmp(resizeType, 'originalRegion')
                    formattedSeedRegionData = rawSeedRegionData;

                    % save individual seed ROI
                    curSeedROIFn = fullfile(seedROIFolderPath, ['seedROI_', num2str(j), '.png']);
                    finalSeedRegHcube = hypercube(formattedSeedRegionData, wavelengthArr);
                    imgSeedROI = hcube2img(finalSeedRegHcube);
                    imwrite(imgSeedROI, curSeedROIFn)

                elseif strcmp(resizeType, 'resize')
                    formattedSeedRegionData = imresize3(rawSeedRegionData, [finalCubeWidth, finalCubeHeight, bandCnt]);

                elseif strcmp(resizeType, 'padding')
                    yPaddingSize = max(ceil((finalCubeHeight - hBoundingBox) / 2), 0);
                    xPaddingSize = max(ceil((finalCubeWidth - wBoundingBox) / 2), 0);
                    formattedSeedRegionData = padarray(rawSeedRegionData, [yPaddingSize, xPaddingSize], 0, 'both');
                    formattedSeedRegionData = imresize3(formattedSeedRegionData, [finalCubeWidth, finalCubeHeight, bandCnt]);

                else
                    logger.info(['ERROR: wrong resize methods: ', resizeType])
                    return
                end
                formattedSeedRegionData = single(formattedSeedRegionData);  % use single to reduce data size

                % remove bands in beginning/end for ROI
                finalSeedRegionData = formattedSeedRegionData;
                finalSeedRegionData(:, :, invalidBandRange) = [];

                % save as .mat
                outputLocalFn = sprintf('seed_%02d.mat', j);
                outputFn = fullfile(finalOutputMatPath, outputLocalFn);
                save(outputFn, 'finalSeedRegionData');
            end
        end
        validSeedCnt = validSeedCnt - extraInvalidSeedCnt;
        clearvars pixelCntArray posArr textArr

        % remove bands in beginning/end for table
        finalWavelengthArr = wavelengthArr;
        finalMergedSeedwiseSpectrum = mergedSeedwiseSpectrum;
        finalWavelengthArr(invalidBandRange) = [];
        finalMergedSeedwiseSpectrum(:, invalidBandRange) = [];

        % write table for the current folder
        rltTable = array2table(finalMergedSeedwiseSpectrum, 'VariableNames', cellstr(num2str(finalWavelengthArr))');
        dataPathCol = repelem(string(curDatasetOutputPath), validSeedCnt);
        seedIdCol = 1:validSeedCnt;
        rltTable = addvars(rltTable, dataPathCol', seedIdCol', 'Before', 1, 'NewVariableNames', {'dataPath', 'seedId'});
        writetable(rltTable, curRltFn);
        mergedRltTbl = [mergedRltTbl; rltTable];

        % close all hidden
        % close all force
    end
    writetable(mergedRltTbl, mergedRltFn);

    %  -- ================================================ End  =======================================================
    logger.info('=======================')
    logger.info('all done!');
    logger.info(['final output folder: ', outputRltPath]);

    % Lamp turns green when processing is done
    lampField.Color = 'green';

end
